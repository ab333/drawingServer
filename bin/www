#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('drawing:server');
var http = require('http');
var socketIo = require('socket.io');
var fs = require('fs'); // File system

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
var io = socketIo.listen(server);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

// array of all lines drawn
var lineHistory = new Array();
var players = new Array(); // player: username, socketId, status, currentRoom
var rooms = new Array(); // room: players[], Id, channelId, status, word1, word2, spy, currentTurn, turnOrder, numOfPlayers, lineHistory
var wordsPath = "words_list_EN.txt";
var words = fs.readFileSync(wordsPath).toString().split('\n');
rooms.push(new Room(0));
// event-handler for new incoming connections
io.on('connection', function (socket) {
    //console.log(socket.io.engine.id);
    console.log(socket.id);
    console.log(getRandomWord());
    socket.join("0");
    // first send the history to the new client
    // NOTE not effective as it will emit every line separately-
    // -instead of sending the whole array once.

    /*for (var i in lineHistory) {
     socket.emit('draw_line', { line: lineHistory[i] } );
     }*/

    // add handler for message type "draw_line".
    socket.on('draw_line', function (data) {
        //find room index
        /*indexes = rooms.map(function(obj, index) {
            if(obj.Id == data.room.Id) {
                return index;
            }
        }).filter(isFinite);
        roomIndex = indexes[0];*/
        // add received line to history
        // verify if sender is the current turn player
        rooms[0].lineHistory.push(data.line); //TODO
        // send line to room
        io.sockets.in("0").emit('draw_line', { line: data.line });
    });

    socket.on('login', function (username) {
        player = new Player(username, socket.id);
        player.status = "logged in";
        players.push(player);
        io.emit('logged_in_succ');
    });
    //
    socket.on('find_room', function (data) {
        //TODO player index etc.
        player = data.player;
        room = findAndJoinRoom(socket, data.criteria, player.index); // returns Room object
        io.emit('joined_room', { room: room });
    });

    socket.on('start_game', function (data) {
        // Artists shouldn't know the other word!
        data.room.status = "started";
        data.room.word2 = "Spy";
        word2 = data.room.word2; // copy word2 so we can reset it after nullifying it.
        data.room.turn = 0; // first player turn; check
        //data.room.players = shuffle(data.room.players); // to define turn order

        // getting The Spy and sending him a message
        spyIndex = getRandomInt(0,data.room.players.length);
        spySocketId = data.room.players[spyIndex].socketId;
        socket.broadcast.to(spySocketId).emit('you_are_spy', { room: data.room });

        // setting the word and sending it to The Artists
        data.room.word2 = "unknown";
        data.room.word1 = getRandomWord();
        //Sending the actual word to the Artists
        for(i=0;i<data.room.players.length;i++) {
            if(i==spyIndex)
                continue;
            artistSocketId = data.room.players[i].socketId;
            socket.broadcast.to(artistSocketId).emit('you_are_artist', { room: data.room });
        }
        data.room.word2 = word2;
        rooms.push(data.room);
    });

    socket.on('end_my_turn', function (data) {
        //many verification needed!
        room = data.room;
        player = data.player;
        room.currentTurn = ( room.currentTurn + 1 ) % room.players.length;
        socket.broadcast.to(room.id).emit('proceed_to_next_turn');
    });


});


/**
 * My Functions
 */

function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function getRandomWord() {
    wordIndex = getRandomInt(0, words.length);
    return words[wordIndex];
}

function findAndJoinRoom(socket, criteria, username) {
    //TODO must get room index instead of value
    player = getPlayerByUsername(username);
    var result = rooms.filter(function( obj ) {
        return obj.status == "open" && obj.type == "public";
    });
    if(result.length == 0) {
        room = new Room(getRandomInt(1,10000));
        room.players.push(player);
        room.numOfPlayers = 1;
        socket.join(room.id);
    }
    else {
        //access result[0]
        room = result[0];
        room.players.push(player);
        //add numOfPlayers limit
        room.numOfPlayers++;
        socket.join(room.id);
    }
    return room;
}

function getPlayerByUsername(username) {
    var result = players.filter(function( player ) {
        return player.username == username;
    });
    if(result.length == 0)
        return null;
    else if(result.length == 1)
        return result[0];
    else
        return null; //users with the same username

}

function getRoomByRoomId(roomId) {
    var result = rooms.filter(function( room ) {
        return room.id == roomId;
    });
    if(result.length == 0)
        return null;
    else if(result.length == 1)
        return resutl[0];
    else
        return null;
}

function getPlayerBySocketId(socketId) {
    var result = players.filter(function( player ) {
        return player.socketId == socketId;
    });
    if(result.length == 0)
        return null;
    else if(result.length == 1)
        return resutl[0];
    else
        return null;
}

function getRoomBySocketId(socketId) {
    var result = rooms.filter(function( room ) {
        return room.id == socketId;
    });
    if(result.length == 0)
        return null;
    else if(result.length == 1)
        return resutl[0];
    else
        return null;
}

function verifyUsernameSocketOwner(username, socket) {
    var result = players.filter(function( player ) {
        return player.socketId == socket.id && player.username == username;
    });
    if(result.length == 0)
        return false;
    else if(result.length == 1)
        return true;
    else
        return true; // I don't know if this will ever get fired
}

function verifyUsernameInRoom(username, roomId) {
    room = getRoomBySocketId();
    var result = room.players.filter(function( player ) {
        return player.username == username;
    });
    if(result.length == 0)
        return false;
    else if(result.length == 1)
        return true;
    else
        return true; // I don't know if this will ever get fired
}

function verifyUsernameCurrentTurn(username, roomId) {
    room = getRoomByRoomId(roomId);
    if(room == null)
        return null; // no such room
    if(room.getCurrentTurnUsername() == username)
        return true;
    else
        return false;
}



function Player (username, socketId) {
    this.username = username;
    this.socketId = socketId;
    this.currentRoom = 0;
    this.index = "";
}

Player.prototype.getInfo = function() {
    return this.username + ' ' + this.socketId + ' apple';
};

function Room (id) {
    this.players = [];
    this.lineHistory = [];
    this.id = id; // same as channelId
    this.channelId = ""; // not used
    this.status = "open"; //open, word_choosing, running, finished
    this.type = "public"; //public, private
    this.word1 = "";
    this.word2 = "";
    this.spyPlayerIndex = "";
    this.currentTurn = "";
    this.numOfPlayers = "";
    this.turnOrder = "";
    this.scoreLimit = "";
}

Room.prototype.getCurrentTurnUsername = function() {
    return this.players[this.currentTurn].username;
};

function LineHistory() {
    this.line;
}

function Line() {
    this.x;
    this.y;
}
/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
